{"name":"Halfbyte tinybasic","tagline":"A high level language for Arduino and compatibles","body":"On this page, you will find all of the available commands, statements and functions available in Half-Byte Tiny Basic.\r\nNEW\r\n Type NEW and press enter. This will clear out the program space. It does NOT zero out any variables, however. (it is good practice to set your variables at the start of your program. Set them to zero or whatever value you need.)\r\n\r\nRUN\r\n Type RUN to start executing your program. There are no parameters.\r\nSAVE and LOAD\r\n Currently, you can SAVE and LOAD your program by typing SAVE to save it to the EEPROM and LOAD to load it back into RAM. As of this writing, you can ONLY save one program. A future release will allow multiple programs to be saved, possibly to SD Cards. Another limitation in this version is that your program can only have 255 lines save. This limitation should be removed in a later version of Tiny Basic.\r\nLIST, LIST number or LIST number-\r\n Typing LIST and hitting Enter will display the program code in its entirety.\r\n Typing LIST followed by a number will display the program code starting with the specified line number. So, LIST 190 will display the program code starting at line 190.\r\n Typing LIST followed by a number and a dash will display ONLY that line.\r\n\r\nSTATEMENTS EXPLAINED\r\nPRINT and SPRINT\r\n PRINT is, perhaps, the most versatile statement in the language. It has many variations and you will figure them all out in time. You can mix formulas, variables and quoted text in many ways. SPRINT is just like PRINT, only it sends the output directly to the SERIAL port (the TX and RX pins on your console are the SERIAL port.) The examples below are all valid:\r\n PRINT “Hello, World!”\r\nPRINT “My number was “, N\r\n PRINT D,” days until Christmas.”\r\nPRINT M+(R*2)-L\r\n PRINT “The returned value is “, (x/4)+4-8*64,” is that correct?”\r\nPRINT x,” turns remaining.”\r\nPRINT “Turn Number “;\r\nSPRINT G,” was my answer.”\r\nSPRINT “This will only be seen on the serial port.”\r\n\r\nSo, there’s a few things we haven’t discussed. First, the comma. Placing a comma outside of the quotes tells Tiny Basic to print something first, then the quoted text. You can have multiple commas outside the quotes. They separate items to print. For example, say you want to print the values of several variables and then some text:\r\n PRINT A,B,C,” notice how they print together.”\r\nPRINT A,”,”,B,”,”,C,” will print them with a comma between them”\r\nPRINT A,” “,B,” “,C” will print them with a space between them.”\r\n\r\nPlacing a comma at the END of the PRINT statement will result in a SYNTAX ERROR.\r\n Placing a SEMICOLON at the END of the PRINT statement will place the NEXT print space at the end of the current print line. For example:\r\n X=1\r\n PRINT “The next value is “;\r\nX=X+1\r\n PRINT X\r\n\r\nWill result in the value of X showing up after the space in the same line:\r\n\r\nThe next value is 2\r\n\r\nAlso, the parentheses tell Tiny Basic to execute the formula inside them before acting on the rest of the formula. Like in math, parenthesis changes the order of operations.\r\n SERIAL PORT INFO\r\n NOTE: The output of PRINT is ALSO ECHOED on the SERIAL PORT. SPRINT ONLY goes to the serial port. The SERIAL PORT is a special part of the console that allows it to communicate with your computer or another console or device that also contains such a port. A PORT is just another word for connection. On your Half Byte Console and on other Arduino board, it is the TX, RX and GND pins. To connect two of the together, you must remember to reverse the connector pins for TX and RX. For example: on your console you have a green wire on the TX pin, a red wire on the RX pin and a yellow wire on GND. Connect the yellow to GND on BOTH. Connect the other green end to TX and the other red end to RX.\r\n RX—>TX\r\n TX—>RX\r\n GND–>GND\r\n\r\nECHO\r\n To turn off the PRINT echo to the serial port, or to turn it back on, use ECHO. ECHO 1 turns on ECHO, ECHO 0 turns it off.\r\n\r\nECHO\r\n\r\n100 CLS\r\n 110 ECHO 0\r\n 120 PRINT “YOU ARE PLAYER 1”\r\n130 SPRINT”YOU ARE PLAYER 2”\r\n140 PRINT “YOU CAN ONLY SEE THIS”\r\n150 ECHO 1\r\n 160 PRINT “NOW BOTH CAN SEE.”\r\n\r\nFOR Loops\r\n A FOR loop is an enclosed set of statements and functions that will executed a number of times before the loop is completed. We use them for things like pausing the program for a certain time, printing the value of something for a number of times as in a countdown or to calculate something. A FOR statement consists of a start point and an endpoint. You can also specify the increment:\r\n 100 FOR X=1 TO 20\r\n 110 PRINT 20-X\r\n 120 NEXT X\r\n\r\nOr\r\n\r\n100 FOR X=0 TO 100 STEP 10\r\n 110 PRINT X\r\n 120 NEXT X\r\n\r\nWhen the first example is run, it will print 20 minus the value of X and will do so 20 times.\r\n The second example will print the value of X 10 times. Why? Because we told it to STEP by tens. The ‘STEP 10’ says to ADD 10 to the value of X each time it loops.\r\n NOTE: FOR loops MUST reside on a line by themselves. So, the following code is NOT legal:\r\n 110 FOR K=1 TO 100: PRINT K: NEXT K\r\n It must be broken out like this:\r\n 110 FOR K=1 TO 100\r\n 120 PRINT K: NEXT K\r\n\r\nWhile including NEXT on a combined line is OK, it is better to also put it on its own line, if for, nothing else, only for clarity.\r\nNEXT\r\n The NEXT statement closes the FOR loop and is followed by the loop variable as shown in the two FOR loop examples above.\r\n NOTE: FOR loops MUST HAVE A CORRESPONDING NEXT. Also, exiting a for loop before it is finished and then entering it again can result in a stack overflow. What that means is that the system will forget where it was and try to complete the original loop-which is no longer there. It WILL crash the computer.\r\n\r\nIF\r\n To execute a statement based on a condition, use IF followed by an expression and then the statement you want to execute if the expression is true:\r\n\r\n100 X=RND(20)\r\n 110 IF X=15 PRINT”The value of X is 15!”\r\n120 IF X=0 X=1\r\n\r\nWhen run, the above code will:\r\n Print\r\n The value of X is 15!\r\n If x is 15\r\n If x is zero, then the code makes the value of x to be 1.\r\n\r\nExpressions can be as complex or simple as needed. In standard BASIC, the verb ‘THEN’ must follow the expression, in Tiny Basic, THEN is not needed and not allowed. The format of the IF statement is simply:\r\n\r\nIF expression STATEMENT\r\n\r\nSo, IF the expression is true then execute STATEMENT. You can have multiple STATEMENTS as long as they are separated by a colon:\r\n\r\n110 IF X=15 PRINT”The value is 15!”:GOTO 200\r\n\r\nGOTO\r\n GOTO transfers the execution to the line following the GOTO statement.\r\n\r\n180 GOTO 300\r\n\r\nLine 180 will transfer control to line 300 and execution will continue from there.\r\n\r\nGOSUB\r\n GOSUB will temporarily transfer control to the line number after the GOSUB. Execution will continue from that line until the RETURN statement is encountered.\r\n\r\nGOSUB line number\r\n\r\n100 GOSUB 1000\r\n 110 PRINT “Returned from 1000”\r\n ….\r\n1000 X=10\r\n 1010 RETURN\r\n\r\nGOSUB’s are useful if you have code that you will reuse several times. Rather than typing that same code over again, make a subroutine. Remember to end your subroutine with a RETURN. Say you have code that waits for a user to press a key to continue. You need to do that many times in your program. Rather than typing that code over and over, type it once as a subroutine:\r\n\r\n200 GOSUB 1500 #wait for input\r\n 210 PRINT “ “\r\n …\r\n260 GOSUB 1500\r\n 270 #more work\r\n…\r\n310 GOSUB 1500\r\n…\r\n1490 STOP\r\n 1500 A=INKEY(0)\r\n 1510 IF A=-1 GOTO 1500\r\n 1520 RETURN\r\n\r\nAs you can see, there were three times we needed to wait for the user to press a key. If we typed lines 1500 to 1520 each time, that would have added unnecessary code. Using it in a subroutine makes it more efficient. There are things to keep in mind, however…\r\n• You MUST place a RETURN at the end of your subroutine\r\n• You MUST make sure that your code does not ‘wander’ into the subroutine, so place a STOP before the subroutine (as shown in line 1490 above.)\r\n• Any variables used in the subroutine will also be available everywhere else, so if you have a counter in your subroutine, changing it outside of the subroutine could return some unexpected results.\r\n\r\nRETURN\r\n Ends your subroutine and returns control to the next line after the GOSUB.\r\n\r\nREM or #\r\n It is good practice to comment your code so others may follow what you were doing. However, remember that comments, while ignored by Tiny Basic, consume memory. So, when entering code, you may leave them out. If you are giving someone source code, it is best to include them.\r\n\r\nINPUT\r\n INPUT is a way to get numerical data from your user. The value entered is stored in the variable following INPUT:\r\n\r\nINPUT\r\n\r\n100 X=0\r\n 110 PRINT “Enter the new value for X”;\r\n120 INPUT X\r\n 130 PRINT “You entered “,X\r\n\r\nWill result in:\r\n\r\nEnter the new value of X? 20 (entered by the user)\r\n You entered 20\r\n\r\nLegal values are numbers from -32767 to 32767. No decimals or text may be entered using INPUT. You CAN enter text using the INKEY function. See INKEY for more.\r\n\r\nPOKE\r\n POKE allows you to alter the value, directly, of a memory location. For example:\r\n\r\n100 X=1450 #memory location 1450\r\n 110 POKE X,64\r\n\r\nPOKE address, value\r\n\r\nThis example puts the integer 64 in location 1450.\r\n You can use POKE in conjunction with INKEY to accept text from the user.\r\n\r\nCLS\r\n CLS just clears the screen.\r\n\r\nSTOP\r\n STOP ends execution of the program and returns you to the editor.\r\n\r\nSET\r\n SET lights up a pixel at location x,y. X and Y values are the height and width of the video screen. On the chip used in the Half-Byte Console, the 328, those values are 84 and 56 as the screen is 84 pixels wide by 56 high.\r\n\r\nSET x,y\r\n\r\n100 FOR X=1 to 83\r\n 110 SET X,10\r\n 120 NEXT X\r\n\r\nThis code will draw a line, at the 10th position down from the top, across the screen.\r\n\r\n**RESET**\r\n RESET, like SET, uses the same coordinates for the screen and turns off the pixel at that location.\r\n\r\nRESET x,y\r\n\r\n100 FOR X=1 to 83\r\n 110 SET X,10\r\n 120 NEXT X\r\n 130 FOR X=35 to 45\r\n 140 RESET X,10\r\n 150 NEXT X\r\n\r\nThis code will draw the line across the screen, as in the previous example, but then erases part of the line from pixels 35 through 45.\r\n\r\n**CIRCLE**\r\n CIRCLE will draw a circle at the specified coordinates on screen. You must supply the X and Y cords and the radius as well as the ‘color’.\r\nCIRCLE start_x, start_y, radius, color\r\n 100 CLS\r\n 110 CIRCLE 10,10,5,1\r\n\r\nThis example will put a small circle on the screen at 10,10. NOTE: the coordinates you specify will become the CENTER POINT for the circle. That is, it will draw the circle AROUND the x, y co-ordinates going the value of radius out from the point. So, the circle above would actually start at 5,5 since the radius was 5.\r\nLINE\r\n LINE gives you the ability to draw lines on the screen. Specify the start and end points and ‘color’, and Tiny Basic will draw the line, quickly. To use:\r\n LINE start_x, start_y, end_x, end_y, color\r\n\r\n100 CLS\r\n 110 LINE 0,7,79,7,1\r\n 120 CURSOR 0,0\r\n 130 PRINT “UNDERLINED”\r\n140 CURSOR 0,3\r\n\r\nThis example will draw a line starting at position 0 on line 7. It will then put some text on the first text line. This will, effectively, underline the whole text line.\r\n\r\n**BOX**\r\n BOX allows you to quickly draw a box on the screen. You can draw or erase a box or invert a section of the screen.\r\n BOX start_x, start_ y, end_ x, end_y, color, type\r\n 100 CLS\r\n 110 BOX 0,0,79,39,1 #DRAW A BOX AROUND THE SCREEN\r\n 120 BOX 1,1,78,25,2 #INVERT THE TOP SECTION OF THE BOX\r\n 130 CURSOR 5,4\r\n 140 PRINT “BOX DEMO”\r\n150 A=INKEY(0)\r\n 160 IF A=32 BOX 0,1,78,39,2\r\n 170 IF A=13 BOX 1,1,78,39,1\r\n 180 IF A=27 STOP\r\n 190 GOTO 150\r\n\r\nThis example draws a box around the screen, displays a message and then if the user presses the space bar, a section of the screen is inverted. If they user press ENTER, another box is drawn on top of the current box.\r\n\r\n**AWRITE, DWRITE**\r\n AWRITE and DWRITE provide a means to send a signal to either the analog pins or the digital pins. You can use them to blink LED’s, turn on or off things like motors or send data to anything you have connected to your console.\r\n 100 FOR K=1 TO 50\r\n 110 DWRITE 13,1 #TURN ON LED ON PIN 13\r\n 120 FOR I=1 TO 500 #DELAY\r\n 130 NEXT I\r\n 140 DWRITE 13,0 #TURN OFF THE LED\r\n 150 FOR I=1 TO 500\r\n 160 NEXT I\r\n 170 NEXT K\r\n\r\nAWRITE PIN, VALUE\r\nDWRITE PIN, VALUE\r\n\r\nPIN can be any ATMega328 pin number. VALUE can be from 0 to 255. For most items, a one will ‘turn on’ and a zero will ‘turn off’ the item. In the example above, the first DWRITE turned on the ‘pin 13’ LED that is on your console board (it’s the RED LED) while the second DWRITE statement turned it off.\r\nOUT\r\n A special version of DWRITE exists but only for the TX pin. This statement allows communication on the first Serial port. If you connect your console to your computer using the FTDI connector, open a terminal window on your computer (you can do this in the Arduino IDE by pressing CTRL SHIFT M) and then typing:\r\n OUT 65\r\n And you should see an uppercase A appear in the terminal window.\r\n To use:\r\n OUT\r\n 100 CLS\r\n 110 PRINT “Value”;\r\n120 INPUT V\r\n 130 OUT V\r\n 140 GOTO 110\r\n\r\n**MEM**\r\n MEM displays the remaining free memory on your screen.\r\n\r\n**TONE**\r\n TONE emits a tone through the audio output of the console. It takes two parameters, tone and duration.\r\n TONE note, duration\r\n 100 CLS\r\n 110 ?”Duration “;:INPUT D\r\n 120 IF D200 SHIFT 1,3\r\n 160 IF P 170 IF PAD(2)=1 STOP\r\n 180 GOTO 140\r\n\r\nFirst, we put twenty random pixels on screen. Then, we read the Nunchuck and if the user moves left, shft the screen left. If they move right, move right.\r\n The direction to shift values:\r\n UP = 0\r\n DOWN = 1\r\n LEFT = 2\r\n RIGHT = 3\r\n\r\n**INVERT**\r\n One thing you can do to get a user’s attention is to flash the screen. Tiny Basic allows you to do this quickly, by using the INVERT statement. It takes no parameters and its syntax is simply:\r\n\r\nINVERT\r\n\r\n100 CLS\r\n 110 CURSOR 3,2\r\n 120 PRINT “TO CONTINUE WITH”\r\n130 CURSOR 3,3\r\n 140 PRINT “PROCESSING, PRESS C”;\r\n150 A=INKEY(0)\r\n 160 IF A=67 GOTO 210\r\n 170 INVERT\r\n 180 DELAY 500\r\n 190 GOTO 150\r\n…\r\n210 #CONTINUE…\r\n\r\nStarting at line 150, we wait for a key to be pressed. If it is C, goto 210 else, we invert the screen, wait a half second and do it again. If there is no delay, the screen would be just obnoxious. Inserting a delay slows it down a bit.\r\n\r\nFUNCTIONS EXPLAINED\r\n\r\n**ABS**\r\n ABS returns the absolute value of a number. All it really does is make a negative number a positive number. Use it when it does not matter if a number is negative or for formatting reasons.\r\n\r\n110 X=ABS(X)\r\n\r\nIf X is below zero, make x positive.\r\n\r\n**RND**\r\n RND returns a random number from zero to the upper limit specified.\r\n\r\n100 X=RND(100)\r\n 110 IF X<50 X=X+50\r\n 120 PRINT “Your random number (from 50 to 100) is “, X\r\n  \r\n\r\nThis code will generate a random number from 50 to 100. First, it creates the random number from 0 to 100. Then, it checks to see if the number is less than 50. If it is, it will add 50 to the value. This, effectively, makes the number random from 50 to 100.\r\n\r\n \r\n\r\n**PEEK**\r\n\r\nPEEK or @ will return the value of the specified memory location.\r\n  \r\n\r\n100 X=@1450\r\n 110 IF X=13 PRINT “End of line.”\r\n \r\nYou can use PEEK to examine a line of text entered by the user:\r\n  \r\n 1500 #PRINT the name entered\r\n 1510 M=N\r\n 1520 X=@M\r\n 1530 IF X=13 RETURN\r\n 1540 PRINT CHR(X);\r\n 1550 M=M+1\r\n 1560 GOTO 1520\r\n\r\n \r\n Several things in the example to note are:\r\n•Use of the ‘@’ sign instead of PEEK\r\n•Use of the IF statement\r\n•Putting RETURN in a place other than at the end of the subroutine-this is the only legal way to do that.\r\n•How to print the user’s name-provided it is in the memory location at M.\r\n•Use of CHR to print the ASCII representation of the memory location M\r\n\r\n \r\n\r\n**INKEY**\r\n\r\nINKEY will return the ASCII value of the key that was pressed. This function ONLY CHECKS THE KEYBOARD ONE TIME. In other words, it does not wait for a keypress.\r\n\r\n \r\n 1600 #Get User Text\r\n 1610 M=N\r\n 1620 A=INKEY(0)\r\n 1630 IF A=-1 GOTO 1620\r\n 1640 IF A=13 @M,13: RETURN\r\n 1650 PRINT CHR(A);\r\n 1660 @M,A\r\n 1670 M=M+1\r\n 1680 GOTO 1620\r\n  \r\n\r\nThis subroutine lets you get a line of text from the user. If no key has been pressed, A will get a zero from INKEY. Once a key is pressed, its ASCII value is returned to A. If the user presses ENTER, a carriage return is put in memory to denote the end of the line and control is returned to the calling code. Everything else is stored in memory and the memory location is incremented by one.  NOTE: no check is made to make sure the memory location is valid. It is assumed to be when the subroutine is called.  You specify the value of the memory location in the ‘N’ variable.  You can use any variable you wish, just change the ‘N’ in line 1610 accordingly.\r\n  \r\n  \r\n\r\n**CHR**\r\n\r\nCHR, used with PRINT, will display the visual representation of the value specified.\r\n  \r\n 100 C=65\r\n 110 PRINT CHR(C)\r\n  \r\n Will result in an A being displayed on screen.\r\n  \r\n\r\n**TOP**\r\n\r\nTOP will return the location AFTER the end of your program. This is useful to know when using memory for string storage. This can keep you from stepping on your code.\r\n\r\n \r\n 100 A=TOP(0)\r\n 110 POKE A,65\r\n 120 PRINT PEEK(A),”=”,CHR(PEEK(A))\r\n  \r\n This little snippet of code will put the letter ‘A’ in the first free spot of memory. It then prints out what is in that spot and its visual representation, an ‘A’ in this case.\r\n  \r\n  \r\n\r\n**PAD**\r\n\r\nPAD(0) and PAD(1) will read the x and y values from the thumbstick of the Wii Nunchuk. PAD(0) will return the X-axis value and PAD(1) will return the Y-axis value. PAD(2) and PAD(3) return the C and Z buttons while PAD(4), PAD(5) and PAD(6) return the x,y and z positions of the accelerometer.\r\n\r\n \r\n 100 X=1: Y=1         #INITIALIZE OUR START\r\n 110 SET(X,Y)\r\n 120 P=PAD(0)         #GET THE X VALUE\r\n 130 Q=PAD(1)        #GET THE Y VALUE\r\n 140 IF P>200 X=X+1   #IF VALUE IS MORE THAN 200, GO RIGHT\r\n 150 IF P<100 X=X-1   #IF VALUE IS LESS THAN 100, GO LEFT\r\n 160 IF Q>200 Y=Y+1\r\n 170 IF Q<100 Y=Y-1\r\n 180 SET(X,Y)         #LIGHT UP THE PIXEL\r\n 190 IF PAD(3) STOP   #IF Z BUTTON IS PRESSED, STOP\r\n 200 IF PAD(2) RUN    #IF C BUTTON IS PRESSED, RESTART\r\n 210 GOTO 120        #DO IT AGAIN\r\n  \r\n\r\nThis code will read the x and y axis of the Wii Nunchuk and move either left, right, up or down. Pressing the ‘Z’ button end and the ‘C’ button will clear the screen and allow you to start over.\r\n\r\n \r\n\r\nPAD number Return value \r\n0 Thumbstick x \r\n1 Thumbstick y \r\n2 ‘C’ button \r\n3 ‘Z’button \r\n4 Accelerometer x \r\n5 Accelerometer y \r\n6 Accelerometer z \r\n\r\n\r\n\r\n****GET****\r\n\r\nGET will return the value of a pixel at a given point. So, if the pixel at, say, 5,5 is lit, the function returns a one. If it is not, it will return a zero. This is useful for detecting a collision in a game.\r\n\r\n 100 CLS\r\n 110 x=rnd(40): y=rnd(20)\r\n 120 set x,y\r\n 130 x=rnd(40):y=rnd(20)\r\n 140 if get(x,y)=1 reset x,y\r\n 150 goto 120\r\n  \r\n\r\nThis example puts random pixels on the screen, generates another set of random locations, tests the location and, if it is lit up, then turn it off. This will keep the screen from filling up.\r\n  \r\n  \r\n\r\nSTRING ASSIGNMENT\r\n\r\nYou can store a string directly in a memory location, in code, by using a quoted string in your POKE statement. ONLY quoted strings are allowed.\r\n\r\n \r\n 100 #QUOTED STRING EXAMPLE\r\n 110 A=TOP(0)\r\n 120 @A,”MY QUOTED STRING”\r\n 130 FOR Z=A TO A+64\r\n 140 B=@Z\r\n 150 IF B=13 Z=A+64\r\n 160 PRINT CHR(B);\r\n 170 NEXT Z\r\n\r\n \r\n When you assign a quoted string to a memory location, a carriage return is appended to the string. You can use that carriage return to then look for the end of the string.\r\n  \r\n Using a quoted string is good if you have several strings you will use over and over.\r\n  \r\n  \r\n\r\nAREAD, DREAD\r\n\r\nAREAD and DREAD will retrieve the current value of the specified PIN.  AREAD will return a value from 0 to 1023 that corresponds to the voltage of said pin. DREAD returns a 0 or  1.  0 is LOW, 1 is HIGH.  To use:\r\n\r\nA=DREAD(PIN)\r\n\r\n100 A=DREAD(0) #GET VALUE OF RX\r\n110 IF A=0 GOTO 100 #LOOP UNTIL THE PIN GOES HIGH\r\n120 PRINT”RX PIN IS HIGH.”\r\n\r\n\r\nMathematical Operations\r\n\r\nInteger math operations (i.e. no decimals, only ‘whole’ numbers) include:\r\n•Addition\r\n•Subtraction\r\n•Multiplication\r\n•Division\r\n•Absolute value\r\n•Power (NOTE: there is a math error, not in Tiny Basic, in the compiler that results in incorrect return values. You will need to add one to the results. For example, 2^2 should return a value of 4, however, it returns a value of 3. Add a 1 to the value to get the correct result. We are looking at a fix for this issue.)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}